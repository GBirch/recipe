<?php
// $Id$

/**
 * @file
 * recipe_mastercook4.module - Enables importing and exporting of MasterCook4 format recipes.
 */


/**
 * Implementation of hook_recipeio($type).
 */
function recipe_mastercook4_recipeio($type) {
  $supported = array(
    'import_single' => array(
      'format_name' => t('MasterCook4'),
      'callback' => 'recipe_mastercook4_import_single',
      'format_help' => ''
    ),
    'export_single' => array(
      'format_name' => t('MasterCook4'),
      'callback' => 'recipe_mastercook4_export_single',
      'format_help' => t('Export to a recipe to a MasterCook(1-4 .mxp) based text format.')
    ),
    'export_multi' => array(
      'format_name' => t('MasterCook4'),
      'callback' => 'recipe_mastercook4_export_multi',
      'format_help' => t('Export all recipes to a MasterCook(1-4 .mxp) based text format.')
    ),
    'import_multi' => array(
      'format_name' => t('MasterCook4'),
      'callback' => 'recipe_mastercook4_import_multi',
      'format_help' => t('Import recipes from a MasterCook(1-4 .mxp) based text file.')
    )
  );
  if ( isset($supported[$type]) ) {
    return array('mastercook4' => $supported[$type]);
  }
  else {
    return FALSE;
  }
}


function recipe_mastercook4_export_multi() {
  // you should not be able to export unpublished recipes
  $result = db_query("SELECT n.nid from {node} n WHERE n.type='recipe' and n.status>0 ORDER BY n.title");
  $o = '';
  foreach ($result as $record) {
    $o .= recipe_mastercook4_export_single($record->nid);
  }
  drupal_add_http_header('Content-type', 'text/plain; charset=utf-8');
  return $o;
}

function recipe_mastercook4_export_single($nid = NULL, $yield = NULL) {
  if ( $nid === NULL ) {
    drupal_set_message(t('Recipe not found.'));
    drupal_not_found();
    return;
  }
  $node = node_load($nid);

  // you should not be able to export unpublished recipes
  if ( $node->status == 0 ) {
    drupal_access_denied();
    return;
  }

  // Set the custom yield so we can scale up/down the recipe quantities.
  $node->recipe->custom_yield = $yield;


  drupal_add_http_header('Content-type', 'text/plain; charset=utf-8');
  return merge_template($node);
}


function merge_template($node = NULL) {

  //prepare prepare time
  $decimal_hours = $node->recipe->preptime/60;
  $hours = floor($decimal_hours);
  $minutes = sprintf("%02d", floor(($decimal_hours - $hours)*60));
  $preptime = "$hours:$minutes";

  //prepare categories
  $categories = '';
/*
  $vocabs = taxonomy_get_vocabularies('recipe');
  foreach ($vocabs as $vocab) {
    $terms = taxonomy_node_get_terms_by_vocabulary($node, $vocab->vid);
    foreach ( $terms as $term ) {
      $term = array_shift($terms);
      $categories .= sprintf("%-33s", $term->name);
    }
  }
  $categories = wordwrap($categories, 66, "\n                ");
*/
  //prepare ingredients
  $factor = 1;
  if (isset($node->recipe->custom_yield)) {
    $factor = $node->recipe->custom_yield / $node->recipe->yield;
    $node->recipe->yield = $node->recipe->custom_yield;
  }

  $ingredients = '';
  foreach ( $node->recipe->ingredients as $key => $i ) {
    if ($i['quantity'] > 0) {
      $i['quantity'] *= $factor;
    }
    else {
      $i['quantity'] = ' ';
    }
    $ingredients .= format_mastercook4_ingredient($i);
  }

  // get the template string
  $template = get_template();
  // merge title
  $template = str_replace("<<title>>", $node->title, $template);
  // merge recipe by
  $template = str_replace("<<recipeby>>", $node->recipe->source, $template);
  // merge serving size
  $template = str_replace("<<servingsize>>", $node->recipe->yield, $template);
  // merge preptime
  $template = str_replace("<<preptime>>", $preptime, $template);
  // merge categories
  $template = str_replace("<<categories>>", $categories, $template);
  // merge ingredients
  $template = str_replace("<<ingredients>>", $ingredients, $template);
  // merge instructions
  $template = str_replace("<<instructions>>", strip_html_and_encode_entities($node->recipe->instructions), $template);
  // merge notes
  if ( $node->recipe->notes != '' ) {
    $node->recipe->notes = "NOTES : " . strip_html_and_encode_entities($node->recipe->notes);
  }
  $template = str_replace("<<notes>>", $node->recipe->notes, $template);

  return $template;
}


function get_template() {
$template = "
                     *  Exported from  MasterCook  *

<<title>>

Recipe By     : <<recipeby>>
Serving Size  : <<servingsize>>   Preparation Time :<<preptime>>
Categories    : <<categories>>

  Amount  Measure       Ingredient -- Preparation Method
--------  ------------  --------------------------------
<<ingredients>>
<<instructions>>

                   - - - - - - - - - - - - - - - - - -

<<notes>>
";
return $template;
}


function format_mastercook4_ingredient($ingredient = NULL) {
  $ingredient['quantity'] = recipe_ingredient_quantity_from_decimal($ingredient['quantity'], TRUE);
  // no html entities
  $ingredient['quantity'] = str_replace('&frasl;', '/', $ingredient['quantity']);
  $ingredient['unit_name'] = recipe_unit_name($ingredient['unit_id']);
  $fullingredient = strlen($ingredient['note']) > 0 ? $ingredient['name'] . ' -- ' . $ingredient['note'] : $ingredient['name'];
  $fullingredient = strip_html_and_encode_entities($fullingredient);
  $fullingredient = wordwrap($fullingredient, 66, "\n                        ");
  $o = sprintf("%8s  %-12s  %s\n", $ingredient['quantity'], $ingredient['unit_name'], $fullingredient);
  return $o;
}


function recipe_mastercook4_import_multi() {
  $o = drupal_get_form('recipe_mastercook4_import_form');
  return $o;
}


function recipe_mastercook4_import_form($form_state) {
  $form = array();
  $form['#attributes'] = array('enctype' => "multipart/form-data");
  $form['recipe_import_file'] = array(
    '#type' => 'file',
    '#title' => t('MasterCook(1-4 .mxp) File'),
    '#default_value' => '',
    '#size' => 64,
    '#description' => t("Note: This will add taxonomy terms to the lightest weight recipe taxonomy."),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Import'),
  );
  return $form;
}


function recipe_mastercook4_import_form_submit($form, &$form_state) {

  // save to a temp files
  $data = array();
  $validators = array('file_validate_extensions' => array('mxp xml'));
  if ($file = file_save_upload('recipe_import_file', $validators, FALSE, FILE_EXISTS_RENAME)) {
    $data = file($file->uri);
    drupal_set_message(t('The attached file was successfully uploaded'));
  }
  else {
    drupal_set_message(t('The attched file failed to upload.'), 'error');
    return;
  }

  $recipe_txt = '';

  // Get the vocabs first.
/*
  $vocabs = taxonomy_get_vocabularies('recipe');
  list($lightest_vid, $vocab) = each($vocabs);
  reset($vocabs);
*/
  foreach ($data as $line) {
    if ( preg_match("/\* +Exported +from/i", $line) ) {
      $recipe_txt = trim($recipe_txt);
      // Save recipe
      if ( strlen($recipe_txt) > 0 ) {
        $parsed_recipe_object = recipe_mastercook4_import_single($recipe_txt);
        if ( strlen($parsed_recipe_object['title']) > 0 ) {
          if ( ($node = recipe_import_get_node($parsed_recipe_object)) != FALSE ) {

            // Save the taxonomy.
/*
            foreach ($parsed_recipe_object['categories'] as $category) {
              // Search the lightest weight recipe vocab for this term.
              $term = recipe_get_term_by_name($category, $lightest_vid);
              // You didn't find that term, so add it.
              if ( $term == FALSE && isset($lightest_vid) ) {
                $term = array('name' => $category, 'vid' => $lightest_vid);
                drupal_set_message(t('Adding term %term_name', array('%term_name' => $category)));
                taxonomy_save_term($term);
                // Cast back to object so it's like the return value from recipe_get_term_by_name().
                $term = (object)$term;
              }
              // You have the term now (existing or new), link it ink.
              if ( isset($term) ) {
                $node->taxonomy[] = $term->tid;
              }
            }
*/
            // Save the recipe.
            node_save($node);
          }
        }
      }
      // Clear recipe buffer.
      $recipe_txt = '';
    }
    $recipe_txt .= $line;
  }

  // Handle the last one needed.
  $parsed_recipe_object = recipe_mastercook4_import_single($recipe_txt);
  if ( strlen($parsed_recipe_object['title']) > 0 ) {
    if ( ($node = recipe_import_get_node($parsed_recipe_object)) != FALSE ) {
      node_save($node);
    }
  }
}

function recipe_mastercook4_import_single($recipe_txt = NULL) {

  // loose bad characters.
  $recipe_txt = fixEncoding($recipe_txt);

  // region constants
  $reg = array(
    'head' => 0,
    'title' => 1,
    'meta' => 2,
    'ingredients' => 3,
    'directions' => 4,
    'notes' => 5,
    'eor' => 6,
  );

  $recipe = array(
    'title' => '',
    'yield' => '1',
    'yield_unit' => 'Servings',
    'categories' => array(),
    'ingredients' => array(),
    'instructions' => '',
    'notes' => '',
    'source' => ''
  );

  // A reference to the last ingredient added.
  $last_ingred_key = NULL;
  $region = $reg['head'];

  $recipe_lines = explode("\n", $recipe_txt);
  foreach ($recipe_lines as $line) {
    $trimmed_line = trim($line);

    // Head
    if ( $region == $reg['head']) {
      // blank line in head section, move to next section.
      if ( $trimmed_line == '' ) {
        $region++;
        continue;
      }
    }

    // Title
    if ( $region == $reg['title'] ) {
      // Capture title.
      if ( $trimmed_line != '' ) {
        $recipe['title'] = $trimmed_line;
      }
      else {
        // blank line in title section, move to next section.
        $region++;
        continue;
      }
    }

    if ( $region == $reg['meta'] ) {

      // Get the source.
      if ( preg_match('/Recipe +By *: *(.*)/i', $line, $matches) ) {
        $recipe['source'] = $matches[1];
      }

      // Get the categories.
      if ( preg_match('/Categories *: *(.*)/i', $line, $matches) ) {
        $cat1 = trim(substr($matches[1], 0, 33));
        $cat2 = trim(substr($matches[1], 33, 33));
        if ( $cat1 != '' ) {
          $recipe['categories'][] = $cat1;
        }
        if ( $cat2 != '' ) {
          $recipe['categories'][] = $cat2;
        }
      }
      // Category continuation.
      if ( count($recipe['categories']) > 0 && preg_match('/^ {16}(.*)/', $line, $matches) ) {
        $cat1 = trim(substr($matches[1], 0, 33));
        $cat2 = trim(substr($matches[1], 33, 33));
        if ( $cat1 != '' ) {
          $recipe['categories'][] = $cat1;
        }
        if ( $cat2 != '' ) {
          $recipe['categories'][] = $cat2;
        }
      }

      // blank line in meta section, move to next section.
      if ( $trimmed_line == '' ) {
        $region++;
        continue;
      }
    }

    if ( $region == $reg['ingredients'] ) {

      if ( preg_match('/Amount +Measure +Ingredient +-- +Preparation Method/i', $line) ) {
        // Do nothing.
      }
      elseif ( preg_match('/-------- +------------ +--------------------------------/', $line) ) {
        // Do nothing.
      }
      elseif ( $trimmed_line != '' ) {

        $q = trim(substr($line, 0, 8));
        $u = trim(substr($line, 10, 12));
        $i = trim(substr($line, 24));

        // If you have an ingredient continuation, add note to previous ingredient.
        if ($q == '' && $u == '' && $last_ingred_key != NULL) {
          $recipe['ingredients'][$last_ingred_key]['ingredient_note'] .= ' ' . $i;

        // For non-ingredient continuation, add ingredient like normal.
        }
        else {
          $ing = array(
            'ingredient_name' => '',
            'ingredient_note' => '',
          );
          $ing['quantity'] = $q;
          $ing['unit_name'] = $u;

          if ( preg_match('/(.*?) ?-- ?(.*)/', $i, $matches) ) {
            $ing['ingredient_name'] = $matches[1];
            $ing['ingredient_note'] = $matches[2];
          }
          else {
            $ing['ingredient_name'] = $i;
          }

          // Look up units in the units table.
          // If it is not found, use the generic 'unit' object and place the original in 'notes'.
          $ing['unit_obj'] = recipe_unit_fuzzymatch($ing['unit_name']);
          if ( $ing['unit_obj'] == FALSE ) {
            $ing['ingredient_note'] = $ing['unit_name'] . '! ' . $ing['ingredient_note'];
            $ing['unit_name'] = 'Unit';
            $ing['unit_obj'] = recipe_unit_fuzzymatch($ing['unit_name']);
            drupal_set_message(t('Could not find the ingredient units in :recipe (:line)', array(':recipe' => $recipe['title'], ':line' => $line)), 'warning');
          }

          // Look up the ingredient, if it is not found it will be added later at node_save.
          $ing['ingred_obj'] = recipe_ingredient_match($ing['ingredient_name']);

          $recipe['ingredients'][] = $ing;
          end($recipe['ingredients']);
          $last_ingred_key = key($recipe['ingredients']);
        }
      }
      else {
        // blank line in ingredient section, move to next section.
        $region++;
        continue;
      }
    }
    elseif ( $region == $reg['directions'] ) {
      if ( preg_match('/- - - - - - - - - - - - - - - - - -/', $line) ) {
        $region++;
        continue;
      }

      if ( preg_match('/^Notes: +(.*)/i', $line, $matches) ) {
        $recipe['notes'] .= $matches[1] ."\n";
        $region++;
        continue;
      }
      else {
        $recipe['instructions'] .= $line ."\n";
      }
    }
    elseif ( $region == $reg['notes'] ) {
      $recipe['notes'] .= $line ."\n";
    }

  }

  return $recipe;
}
