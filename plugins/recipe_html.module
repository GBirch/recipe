<?php

/**
 * @file
 * recipe_recipeML.module - Enables importing and exporting of recipeML format recipes.
 */

/**
 * Implementation of hook_recipeio($type).
 */
function recipe_html_recipeio($type) {
  $supported = array(
    'export_single' => array(
      'format_name' => t('HTML'),
      'callback' => 'recipe_html_export_single',
      'format_help' => t('Export to a printer friendly HTML format.'),
      'access arguments' => 'access content',   // everyone should be able to export HTML
    )
  );

  if ( isset($supported[$type]) ) {
    return array('reciphtml' => $supported[$type]);
  }
  else {
    return FALSE;
  }
}

/**
 * Example implementation of hook_perm().  If you need special permissions for a format,
 * use this and match the permission name to the access arguments above.

function recipe_html_perm() {
  return array(t('export single'));
}
*/


function recipe_html_export_single($nid = NULL, $yield = NULL) {
  if ( $nid === NULL ) {
    drupal_set_message(t('Recipe not found.'));
    drupal_not_found();
    return;
  }
  $node = node_load($nid);

  // Set the custom yield so we can scale up/down the recipe quantities.
  $node->recipe->custom_yield = $yield;

  // Remove the yield buttons.
  $node->recipe->show_yield_form = FALSE;

  // you should not be able to export unpublished recipes
  if ( $node->status == 0 ) {
    drupal_access_denied();
    return;
  }

  $elements = node_view($node, 'full');

  return theme('recipe_export_html_page', array('elements' => $elements));
}


/**
 * Implementation of hook_theme().
 */
function recipe_html_theme() {
  return array(
    'recipe_export_html_page' => array(
      'function' => 'theme_recipe_export_html_page',
      'variables' => array('variables' => NULL),
    ),

    'recipe_html_node' => array(
      'template' => 'recipe_html_node',
      'variables' => array('variables' => NULL),
    ),

  );
}


function recipe_html_preprocess_recipe_html_node(&$variables) {

  // Return immediately if this node is not a recipe or if this is a teaser (teaser doesn't use special recipe fields).
  // This gets called for all node types.
  $type = $variables['elements']['#node']->type;
  if ($type != 'recipe') {
    return;
  }

  template_preprocess_node($variables);
}


/**
 * How the recipe's HTML export should be themed.
 *
 * @ingroup themeable
 */
function theme_recipe_export_html_page($variables) {

  global $base_url;
  $html = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n";
  $html .= '<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">';
  $html .= "<head>\n<title>". check_plain($variables['elements']['#node']->title) ."</title>\n";
  $html .= '<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />';
  $html .= '<base href="'. $base_url .'/" />'."\n";
  $html .= "<style type=\"text/css\">\n@import url(". drupal_get_path('module', 'recipe') ."/recipe.css);\n</style>\n";
  # 'title' is exception to "all recipe titles in recipe CSS namespace" rule
  $html .= "</head>\n<body>\n". theme('recipe_html_node', array('elements' => $variables['elements'])) ."\n</body>\n</html>\n";
  return $html;
}
