<?php
// $Id$


/**
 * @file
 * recipe.module - share recipes
 */

// $block_delta constants.
define('RECIPE_BLOCK_RECENT', 0);
define('RECIPE_BLOCK_SUMMARY', 1);


/**
 * Implementation of hook_help().
 */
function recipe_help($path, $arg) {
  switch ($path) {
    case 'node/add/recipe':
      return variable_get('recipe_help', '');
    case 'admin/content/recipe/export_multi':
      $output = '<p>' . t('You can enable/disable bulk export formats on the <a href="@modules-page">modules page</a> in the recipes section.', array('@modules-page' => url('admin/build/modules'))) . '</p>';
      return $output;
    case 'admin/content/recipe/import_multi':
      $output = '<p>' . t('You can enable/disable bulk import formats on the <a href="@modules-page">modules page</a> in the recipes section.', array('@modules-page' => url('admin/build/modules'))) . '</p>';
      return $output;
  }
}


/**
 * Implementation of hook_theme().
 */
function recipe_theme($existing, $type, $theme, $path) {

  return array(
    'recipe_landing_page' => array(
      'file' => 'recipe.landing.page.inc'
    ),

    // The ingredients sub-form on the recipe edit screen.
    'ingredients_form' => array(
      'render element' => 'form',
    ),

    'recipe_summary' => array(
      'function' => 'theme_recipe_summary',
      'variables' => array('node' => NULL, 'show_title' => TRUE),
    ),

    'recipe_ingredients' => array(
      'function' => 'theme_recipe_ingredients',
      'variables' => array('node' => NULL),
    ),
    'recipe_category_index_page' => array(
      'variables' => array('tree' => NULL),
      'file' => 'recipe_category_index.inc',
    ),
    'recipe_ingredient_index_page' => array(
      'variables' => array('tree' => NULL),
      'file' => 'recipe_ingredient_index.inc',
    ),
    'recipe_name_index_page' => array(
      'variables' => array('alpha_list' => NULL, 'node_list' => NULL),
      'file' => 'recipe_name_index.inc',
    ),

    'recipe_box' => array(
      'variables' => array('title' => NULL, 'content' => NULL),
    ),
  );
}


/**
 * Implementation of hook_perm().
 */
function recipe_permission() {
  return array(
    'create recipes' => array(
      'title' => t('Create recipes'),
      'description' => t('Create new recipes and add them to the site.'),
    ),
    'edit own recipes' => array(
      'title' => t('Edit own recipes'),
      'description' => t('Edit recipes that the user has created.'),
    ),
    'edit any recipes' => array(
      'title' => t('Edit any recipes'),
      'description' => t('Edit recipes created by anyone.'),
    ),
    'export recipes' => array(
      'title' => t('Export recipes'),
      'description' => t('Export recipes in various formats.'),
    ),
    'import recipes' => array(
      'title' => t('Import recipes'),
      'description' => t('Import recipes in various formats.'),
    ),
  );
}


/**
 * Implementation of hook_load().
 */
function recipe_load($nodes) {
  $result = db_query('SELECT * FROM {recipe} WHERE nid IN (:nids)', array(':nids' => array_keys($nodes)));
  foreach ($result as $record) {
    $nodes[$record->nid]->recipe = $record;
    $nodes[$record->nid]->recipe->ingredients = recipe_load_ingredients($record->nid);
  }
}

/**
 * Implementation of hook_link().
 */
function recipe_link($type, $node = NULL, $teaser = FALSE) {
dsm("recipe_link");
  $links = array();

  if ($type == 'node' && $node->type == 'recipe') {
    if (!$teaser) {
      $formats = module_invoke_all('recipeio', 'export_single');
      foreach ($formats as $key => $format) {
        $perm = isset($format['access arguments']) ? $format['access arguments'] : 'export recipes';
        if (user_access($perm)) {
          $links[$key] = array(
            'title' => $format['format_name'],
            'href' => "recipe/export/$key/$node->nid/__yield__",
            'attributes' => array('title' => $format['format_help']),
          );
        }
      }
    }
    if ( count($links) > 0 ) {
      array_unshift($links, array('title' => '<br/>' . t('Export to') . ':', 'html' => TRUE));
    }
  }

  // Hook-up magic 'ingredient' CCK content type and link to the by ingredient index page.
  elseif ($type == 'node' && $node->type == 'ingredient') {
    $ing = recipe_ingredient_match(trim(strtolower($node->title)));
    if ($ing) {
      $links['where_used'] = array(
        'title' => t('Recipes where used'),
        'href' => "recipe/bying/" . $ing['id']
      );
    }
  }
  return $links;
}

/**
 * Implementation of hook_node_info().
 */
function recipe_node_info() {
  return array(
    'recipe' => array(
      'name' => t('Recipe'),
      'base' => 'recipe',
      'description' => t('Share your favorite recipes with your fellow cooks.'),
    )
  );
}


/**
 * Implementation of hook_insert().
 *
 * Insert a new recipe into the database.
 */
function recipe_insert($node) {

  db_insert('recipe')
    ->fields(array(
      'nid' => $node->nid,
      'source' => $node->source,
      'yield' => $node->yield,
      'yield_unit' => $node->yield_unit,
      'description' => $node->description['value'],
      'instructions' => $node->instructions['value'],
      'notes' => $node->notes['value'],
      'preptime' => $node->preptime
    ))
    ->execute();

  recipe_save_ingredients($node);
}


/**
 * Implementation of hook_update().
 *
 * As an existing node is being updated in the database, we need to do our own
 * database updates.
 */
function recipe_update($node) {

  db_update('recipe')
    ->fields(array(
      'source' => $node->source,
      'yield' => $node->yield,
      'yield_unit' => $node->yield_unit,
      'description' => $node->description['value'],
      'instructions' => $node->instructions['value'],
      'notes' => $node->notes['value'],
      'preptime' => $node->preptime
    ))
    ->condition('nid', $node->nid)
    ->execute();

  recipe_save_ingredients($node);
}


/**
 * Saves the ingredients of a recipe node to the database.
 *
 * @param $node
 *   A node containing an ingredient list.
 */
function recipe_save_ingredients($node) {
  if (!$node->ingredients) {
    $node->ingredients = array();
  }

  foreach ($node->ingredients as $key => $ingredient) {

    // Skip the more ingredients button.
    if ($key == 'recipe_more_ingredients') {
      continue;
    }

    // Delete, if you have a valid ri_id and the ingredient name is blank.
    if ( isset($ingredient['ri_id']) && $ingredient['name'] == '' ) {

      db_delete('recipe_node_ingredient')
        ->condition('id', $ingredient['ri_id'])
        ->execute();
    }

    // Update, if you have a valid ri_id and the ingredient has a name.
    elseif ( isset($ingredient['ri_id']) && $ingredient['name'] != '' ) {
      $ingredient['id'] = recipe_ingredient_id_from_name($ingredient['name']);
      $ingredient['quantity'] = recipe_ingredient_quantity_from_fraction($ingredient['quantity']);

      db_update('recipe_node_ingredient')
        ->fields(array(
          'ingredient_id' => $ingredient['id'],
          'quantity' => $ingredient['quantity'],
          'unit_id' => $ingredient['unit_id'],
          'weight' => $ingredient['weight'],
          'note' => $ingredient['note'],
        ))
        ->condition('id', $ingredient['ri_id'])
        ->execute();

    }

    // Add, if you don't have a valid ri_id and the ingredient has a name.
    elseif (!isset($ingredient['ri_id']) && $ingredient['name'] != '' ) {
      $ingredient['id'] = recipe_ingredient_id_from_name($ingredient['name']);
      $ingredient['quantity'] = recipe_ingredient_quantity_from_fraction($ingredient['quantity']);

      db_insert('recipe_node_ingredient')
        ->fields(array(
          'nid' => $node->nid,
          'ingredient_id' => $ingredient['id'],
          'quantity' => $ingredient['quantity'],
          'unit_id' => $ingredient['unit_id'],
          'weight' => $ingredient['weight'],
          'note' => $ingredient['note'],
        ))
        ->execute();
    }
  }
}


/**
 * Implementation of hook_delete().
 *
 * When a node is deleted, we need to clean up related tables.
 */
function recipe_delete($node) {
  db_query("DELETE FROM {recipe} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {recipe_node_ingredient} WHERE nid = %d", $node->nid);
}

/**
* Implementation of hook_form().
*/
function recipe_form(&$node, $form_state) {

  $type = node_type_get_type($node);

  // Title.
  if ($type->has_title) {
    $form['title'] = array(
      '#type' => 'textfield',
      '#title' => check_plain($type->title_label),
      '#required' => TRUE,
      '#default_value' => $node->title,
      '#maxlength' => 255,
      '#weight' => -6,
    );
  }

  // WYSIWYG
  $form['description'] = array(
    '#title' => t('Description'),
    '#type' => 'text_format',
    '#format' => isset($node->format) ? $node->format : NULL,
    '#default_value' => !empty($node->recipe->description) ? $node->recipe->description : '',
    '#cols' => 60,
    '#rows' => 1,
    '#description' => t('A short description or "teaser" for the recipe.'),
    '#required' => TRUE,
    '#weight' => -5,
  );

  $form['yield'] = array(
    '#type' => 'textfield',
    '#title' => t('Yield'),
    '#default_value' => !empty($node->recipe->yield) ? $node->recipe->yield : '',
    '#size' => 4,
    '#maxlength' => 4,
    '#description' => t('The number of servings the recipe will make (whole number integer, ie 5 or 6).'),
    '#required' => TRUE,
    '#weight' => -4,
  );

  $form['yield_unit'] = array(
    '#type' => 'textfield',
    '#title' => t('Yield Units'),
    '#default_value' => empty($node->recipe->yield_unit) ? t('Servings') : $node->recipe->yield_unit,
    '#size' => 16,
    '#maxlength' => 64,
    '#description' => t('The units for the yield field(ie servings, people, cans, cookies, etc).'),
    '#required' => FALSE,
    '#weight' => -4,
  );

  $form['ingredients'] = array(
    '#type' => 'fieldset',
    '#collapsible' => FALSE,
    '#title' => t('Ingredients'),
    '#tree' => TRUE,
    '#theme' => 'ingredients_form',
    '#weight' => -3,
  );

  // This is the autocomplete callback url.
  $callback = 'recipe/ingredient/autocomplete';

  if ( empty($node->recipe->ingredients) || !is_array($node->recipe->ingredients) ) {
    $node->recipe->ingredients = array();
  }

  if (isset($form_state['add_ingredients']) || count($node->recipe->ingredients) == 0) {
    unset($form_state['add_ingredients']);
    $add_count = variable_get('recipe_add_more_count', 5);
    for ($delta = 0; $delta < $add_count; $delta++) {
      array_push($node->recipe->ingredients, array('ri_id' => NULL, 'quantity' => '', 'unit_id' => '', 'name' => '', 'note' => '', 'weight' => 0));
    }
  }

  // Weights range from -delta to +delta, so delta should be at least half
  // of the amount of blocks present. This makes sure all blocks in the same
  // region get an unique weight.
  $weight_delta = count($node->recipe->ingredients);

  foreach ($node->recipe->ingredients as $id => $ingredient) {
    // Sometimes $ingredient is an array.
    $ingredient = (object)$ingredient;

    $form['ingredients'][$id]['ri_id'] = array(
      '#type' => 'hidden',
      '#value' => $ingredient->ri_id,
    );

    // Strange, but html_entity_decode() doesn't handle &frasl;
    $form['ingredients'][$id]['quantity'] = array(
      '#type' => 'textfield',
      '#title' => t('Quantity'),
      '#default_value' => preg_replace('/\&frasl;/', '/', recipe_ingredient_quantity_from_decimal($ingredient->quantity, TRUE)),
      '#size' => 8,
      '#maxlength' => 8,
    );
    $form['ingredients'][$id]['unit_id'] = array(
      '#type' => 'select',
      '#title' => t('Unit'),
      '#default_value' => $ingredient->unit_id,
      '#options' => recipe_unit_options(),
    );
    $form['ingredients'][$id]['name'] = array(
      '#type' => 'textfield',
      '#title' => t('Name'),
      '#default_value' => $ingredient->name,
      '#size' => 25,
      '#maxlength' => 128,
      '#autocomplete_path' => $callback,
    );
    $form['ingredients'][$id]['note'] = array(
      '#type' => 'textfield',
      '#title' => t('Note'),
      '#default_value' => $ingredient->note,
      '#size' => 40,
      '#maxlength' => 256
    );
    $form['ingredients'][$id]['weight'] = array(
      '#type' => 'weight',
      '#title' => t('Weight'),
      '#default_value' => $ingredient->weight,
      '#delta' => $weight_delta,
    );
  }

  $form['ingredients']['recipe_more_ingredients'] = array(
    '#type' => 'submit',
    '#value' => t('More ingredients'),
    '#description' => t("If the amount of boxes above isn't enough, click here to add more ingredients."),
    '#weight' => 1,
    '#submit' => array('recipe_more_ingredients_submit'),
  );



  // WYSIWYG
  $form['instructions'] = array(
    '#title' => t('Instructions'),
    '#type' => 'text_format',
    '#format' => isset($node->format) ? $node->format : NULL,
    '#default_value' => !empty($node->recipe->instructions) ? $node->recipe->instructions : '',
    '#cols' => 60,
    '#rows' => 10,
    '#description' => t('Step by step instructions on how to prepare and cook the recipe.'),
    '#weight' => -2,
  );

  $form["source"] = array(
    '#type' => 'textfield',
    '#title' => t('Source'),
    '#default_value' => !empty($node->recipe->source) ? $node->recipe->source : '',
    '#size' => 60,
    '#maxlength' => 127,
    '#description' => t('Optional. Does anyone else deserve credit for this recipe?'),
    '#weight' => -2,
  );


  // To allow for wysiwyg, we need a parent key.
  $form['notes']['notes'] = array(
    '#title' => t('Additional notes'),
    '#type' => 'text_format',
    '#format' => isset($node->format) ? $node->format : NULL,
    '#default_value' => !empty($node->recipe->notes) ? $node->recipe->notes : '',
    '#cols' => 60,
    '#rows' => 5,
    '#description' => t('Optional. Describe a great dining experience relating to this recipe, or note which wine or other dishes complement this recipe.'),
    '#weight' => -2,
  );

  $form['preptime'] = array(
    '#type' => 'select',
    '#title' => t('Preparation time'),
    '#default_value' => !empty($node->recipe->preptime) ? $node->recipe->preptime : '',
    '#options' => array(
      5 => t('5 minutes'),
      10 => t('10 minutes'),
      15 => t('15 minutes'),
      20 => t('20 minutes'),
      30 => t('30 minutes'),
      45 => t('45 minutes'),
      60 => t('1 hour'),
      90 => t('1 1/2 hours'),
      120 => t('2 hours'),
      150 => t('2 1/2 hours'),
      180 => t('3 hours'),
      210 => t('3 1/2 hours'),
      240 => t('4 hours'),
      300 => t('5 hours'),
      360 => t('6 hours'),
    ),
    '#description' => t('How long does this recipe take to prepare (i.e. elapsed time)'),
    '#weight' => -1,
  );


  //We still need the parent input format filter set.
  //$form['filter'] = filter_form($node->format);
  // Move the filter form down a bit.
  //$form['filter']['#weight'] = 5;

  return $form;
}


function theme_ingredients_form($variables) {
  $form = $variables['form'];

  $header = array('', t('Quantity'), t('Units'), t('Ingredient name'), t('Processing/Notes'), t('Sort Weight'));
  $rows = array();
  drupal_add_tabledrag('ingredient-list', 'order', 'sibling', 'ingredient-weight');

  foreach (element_children($form) as $key) {

    // Skip the more ingredients button
    if ( is_numeric($key) ) {

      // Set special classes for drag and drop updating.
      $form[$key]['weight']['#attributes']['class'] = array('ingredient-weight');

      // Build the table row.
      $row = array(
        'data' => array(
          array('class' => array('choice-flag')),
          drupal_render($form[$key]['ri_id']) . drupal_render($form[$key]['quantity']),
        ),
        'class' => array('draggable'),
      );
      $row['data'][] = drupal_render($form[$key]['unit_id']);
      $row['data'][] = drupal_render($form[$key]['name']);
      $row['data'][] = drupal_render($form[$key]['note']);
      $row['data'][] = drupal_render($form[$key]['weight']);
      $rows[] = $row;
    }
  }

  $output = theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => array('id' => 'ingredient-list')));
  $output .= drupal_render_children($form);

  return $output;
}


/**
 * Submit handler to add more ingredient rows.  It makes changes to the form state and the
 * entire form is rebuilt during the page reload.
 */
function recipe_more_ingredients_submit($form, &$form_state) {
  $form_state['rebuild'] = TRUE;

  // If they clicked the more ingredients button, set a form_state signal.
  if ($form_state['values']['ingredients']['recipe_more_ingredients']) {
    $form_state['add_ingredients'] = 1;
  }
}

/**
 * Implementation of hook_menu().
 *
 * Note: when editing this function you must visit 'admin/menu' to reset the cache
 */
function recipe_menu() {

  // Add a tab on the recipe add screen for Recipe Import.
  // Need to add 'file path' because some modules render node/add/recipe/std
  // even though they shouldn't.
  $items['node/add/recipe/std'] = array(
    'title' => 'Standard entry',
    'weight' => 0,
    'file path' => drupal_get_path('module', 'node'),
    'type' => MENU_DEFAULT_LOCAL_TASK
  );
  $items['node/add/recipe/import'] = array(
    'title' => 'Recipe Import',
    'description' => 'Allows you to create a recipe by pasting various formats into a big text box.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('recipe_import_form'),
    'access callback' => 'recipe_import_myaccess',
    'access arguments' => array('import recipes'),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK
  );

  $items['recipe'] = array(
    'title' => 'Recipes',
    'page callback' => 'recipe_landing_page',
    'access arguments' => array('access content'),
    'file' => 'recipe.landing.page.inc'
  );
  $items['recipe/byname'] = array(
    'title' => 'By name',
    'description' => 'Find individual recipes by name.',
    'page callback' => 'recipe_name_index_page',
    'access arguments' => array('access content'),
    'file' => 'recipe_name_index.inc',
    'weight' => -1
  );
/*
  $items['recipe/bycat'] = array(
    'title' => 'By category',
    'description' => 'Find individual recipes by using the category list.',
    'page callback' => 'recipe_category_index_page',
    'access arguments' => array('access content'),
    'file' => 'recipe_category_index.inc'
  );
*/
  $items['recipe/bying'] = array(
    'title' => 'By ingredient',
    'description' => 'Find individual recipes by their ingredients.',
    'page callback' => 'recipe_ingredient_index_page',
    'access arguments' => array('access content'),
    'file' => 'recipe_ingredient_index.inc'
  );

  $items['recipe/ingredient/autocomplete'] = array(
    'title' => 'Ingredient autocomplete',
    'page callback' => 'recipe_autocomplete_page',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),
  );

  $items['recipe/export'] = array(
    'page callback' => 'recipe_export',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),  // lower level permissions are handled in recipe_export
  );



  // Admin menus below here.
  $items['admin/content/recipe'] = array(
    'title' => 'Recipes',
    'description' => 'Settings that control how the recipe module functions.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('recipe_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
    'file' => 'recipe.admin.inc',
  );
  $items['admin/content/recipe/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );
  $items['admin/content/recipe/recipe_index'] = array(
    'title' => 'Indexes',
    'description' => 'Configure settings for the recipe index page.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('recipe_index_settings_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'recipe.admin.inc',
  );
  $items['admin/content/recipe/export_multi'] = array(
    'title' => 'Bulk export',
    'description' => 'Export all recipes from this site into a supported output format.  The data is returned directly to your web browser.  You can enable output formats on the modules screen.',
    'page callback' => 'recipe_export_multi',
    'access callback' => 'recipe_export_multi_myaccess',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
    'file' => 'recipe.admin.inc',
  );
  $items['admin/content/recipe/import_multi'] = array(
    'title' => 'Bulk import',
    'description' => 'Import recipes in a supported input format into this site.  The data is uploaded as a file to the server.  You can enable input formats on the modules screen.',
    'page callback' => 'recipe_import_multi',
    'access callback' => 'recipe_import_multi_myaccess',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
    'file' => 'recipe.admin.inc',
  );


  return $items;
}


/**
 * Implementation of hook_node_access().
 */
function recipe_node_access($node, $op, $account) {

  if ($op == 'create') {
    return user_access('create recipes', $account);
  }

  if ($op == 'update' || $op == 'delete') {
    if ( (user_access('edit own recipes', $account) && ($account->uid == $node->uid)) || user_access('edit any recipes', $account)) {
      return TRUE;
    }
  }
}


/*
 * Block API
 */
function recipe_block_info() {
  $blocks = array();
  $blocks['recent'] = array(
    'info' => t('Newest recipes'),
  );
  $blocks['summary'] = array(
    'info' => t('Recipe summary'),
  );
  return $blocks;
}
function recipe_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'recent':
      // The subject is displayed at the top of the block. Note that it
      // should be passed through t() for translation.
      $block['subject'] = t('Newest Recipes');
      // The content of the block is typically generated by calling a custom
      // function.
      $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title, n.uid, u.name FROM {node} n INNER JOIN {node_revisions} r ON n.vid = r.vid INNER JOIN {users} u ON n.uid = u.uid WHERE n.type='recipe' AND n.status =1 ORDER BY n.created DESC"), 0, 5);
      $block["content"] = node_title_list($result);
      break;

    case 'summary':
      if ( variable_get('recipe_summary_location', 0) == 1 ) {
        if (user_access('access content')) {
          if (arg(0) == 'node' && is_numeric(arg(1)) && (arg(2) == '' || arg(2) == 'view')) {
            $node = node_load(arg(1));
            if ( $node->type == 'recipe' ) {
              $block['subject'] = variable_get('recipe_summary_title', t('Summary'));
              $block['content'] = theme('recipe_summary', array('node' => $node, 'show_title' => FALSE, 'show_yield_form' => FALSE));
              return $block;
            }
          }
        }
      }
      break;


  }
}


/**
 * Implementation of hook_view().
 */
function recipe_view($node, $view_mode) {
  drupal_add_css(drupal_get_path('module', 'recipe') . '/recipe.css');

  if ($view_mode == 'full' && node_is_page($node)) {
    $breadcrumb = array();
    $breadcrumb[] = l(t('Home'), NULL);
    $breadcrumb[] = l(t('Recipes'), 'recipe');

/*
    if ($vocabs = taxonomy_get_vocabularies('recipe')) {
      $vocab = array_shift($vocabs);
      if ($terms = taxonomy_node_get_terms_by_vocabulary($node, $vocab->vid)) {
        $term = array_shift($terms);
        if ($parents = taxonomy_get_parents_all($term->tid)) {
          $parents = array_reverse($parents);
          foreach ($parents as $p) {
            $breadcrumb[] = l($p->name, 'recipe/bycat/' . $p->tid);
          }
        }
      }
    }
*/
    drupal_set_breadcrumb($breadcrumb);

/*
    // Remove taxo links if you are showing the summary.
    if (variable_get('recipe_summary_location', 0) < 2) {
      // Remove each node term that is from a recipe vocab.
      $recipe_vocabs = taxonomy_get_vocabularies('recipe');
      foreach ($node->taxonomy as $tid => $term) {
        if (isset($recipe_vocabs[$term->vid])) {
          unset($node->taxonomy[$tid]);
        }
      }
    }
*/

  }

  // If it is a teaser, you're done.
  if ($view_mode == 'teaser') {
    return $node;
  }

  // Prepare and sanitize node fields.
  $node = recipe_node_sanitize($node);


  // Calculate yield and ingredient factor.

  // Get custom yield or default to a factor of 1.
  $node->recipe->yield = intval($node->recipe->yield);
  // Factor is calculated and added into the $node variable.
  $node->recipe->factor = 1;

  // check post variable to see if the yield form was posted.
  if ( $node->recipe->yield != 0 && isset($_POST['op'])) {
    if ($_POST['op'] == t('Change')) {
      $node->recipe->factor = $_POST['custom_yield'] / $node->recipe->yield;
      $node->recipe->yield = $_POST['custom_yield'];
      $_POST = array();
    }
    elseif ($_POST['op'] == t('Halve')) {
      $node->recipe->factor = $_POST['custom_yield']/2 / $node->recipe->yield;
      $node->recipe->yield = $_POST['custom_yield']/2;
      $_POST = array();
    }
    elseif ($_POST['op'] == t('Double')) {
      $node->recipe->factor = $_POST['custom_yield']*2 / $node->recipe->yield;
      $node->recipe->yield = $_POST['custom_yield']*2;
      $_POST = array();
    }
    // Reset yield back to recipe default
    elseif ($_POST['op'] == t('Reset')) {
      $_POST = array();
    }
  }
  // Custom_yield comes from export single urls currently.
  elseif (isset($node->recipe->custom_yield)) {
    $node->recipe->factor = $node->recipe->custom_yield / $node->recipe->yield;
    $node->recipe->yield = $node->recipe->custom_yield;
  }


  // Begin filling the node->content array with with recipe items.

  $node->content['recipe_description'] = array(
      '#markup' => '<div class="recipe-description">' . theme('recipe_box', array('title' => t('Description'), 'content' => $node->recipe->description)) . '</div>',
      '#weight' => recipe_content_extra_field_weight('description')
  );

  $node->content['recipe_ingredients'] = array(
      '#markup' => '<div class="recipe-ingredients">' . theme('recipe_box', array('title' => t('Ingredients'), 'content' => theme('recipe_ingredients', array('node' => $node)))) . '</div>',
      '#weight' => recipe_content_extra_field_weight('ingredients')
  );

  $node->content['recipe_instructions'] = array(
      '#markup' => '<div class="recipe-instructions">' . theme('recipe_box', array('title' => t('Instructions'), 'content' => $node->recipe->instructions)) . '</div>',
      '#weight' => recipe_content_extra_field_weight('instructions')
  );

  // Don't show the notes box at all it there are no notes.
  if ( $node->recipe->notes ) {
    $node->content['recipe_notes'] = array(
        '#markup' => '<div class="recipe-notes">' . theme('recipe_box', array('title' => t('Notes'), 'content' => $node->recipe->notes)) . '</div>',
        '#weight' => recipe_content_extra_field_weight('notes')
    );
  }

  // If you are showing the summary in the node content.
  if (variable_get('recipe_summary_location', 0) == 0) {
    $node->content['recipe_summary_box'] = array(
        '#markup' => '<div class="recipe-summary">' . theme('recipe_summary', array('node' => $node, 'show_yield_form' => isset($node->recipe->show_yield_form) ? $node->recipe->show_yield_form : TRUE)) . '</div>',
        '#weight' => recipe_content_extra_field_weight('summary_box')
    );
  }

  return $node;
}


/**
 * Implements hook_node_view().
 */
function recipe_node_view($node, $view_mode) {
  if ($node->type == 'recipe' && $view_mode != 'rss') {
    $formats = module_invoke_all('recipeio', 'export_single');
    $links = array();
    foreach ($formats as $key => $format) {
      $perm = isset($format['access arguments']) ? $format['access arguments'] : 'export recipes';
      if (user_access($perm)) {
        $links[$key] = array(
          'title' => $format['format_name'],
          'href' => "recipe/export/$key/$node->nid/" . $node->recipe->yield,
          'attributes' => array('title' => $format['format_help']),
        );
      }
    }

    if (!empty($links)) {
      array_unshift($links, array('title' => '<br/>' . t('Export to') . ':', 'html' => TRUE));
      $node->content['links']['recipe'] = array(
        '#theme' => 'links__recipe__node',
        '#links' => $links,
        '#attributes' => array('class' => array('links', 'inline')),
      );
    }
  }
}



function theme_recipe_ingredients($variables) {
  $node = $variables['node'];
  $output = '';

  // Construct the $ingredients[] array.
  if ($node->recipe->ingredients != NULL) {
    $output .= '<table>';
    foreach ($node->recipe->ingredients as $ingredient) {
      $ingredient = (object)$ingredient;
      if (isset($ingredient->quantity) && $ingredient->name) {
        if (!$ingredient->abbreviation) {
          $ingredient->abbreviation = recipe_unit_abbreviation($ingredient->unit_id);
        }
        if ($ingredient->abbreviation == '') {
          $ingredient->abbreviation = '&nbsp;';
        }

        // In preview mode the quantity are plain text fractions and should not be multiplied.

        //if ( !$node->in_preview ) {
          if ($ingredient->quantity > 0) {
            $ingredient->quantity *= $node->recipe->factor;
          }
          else {
            $ingredient->quantity = '&nbsp;';
          }
          if (variable_get('recipe_fraction_display', t('{%d} %d&frasl;%d'))) {
            $ingredient->quantity = recipe_ingredient_quantity_from_decimal($ingredient->quantity);
          }
        //}

        if (!empty($ingredient->link)) {
          $ingredient->name = l($ingredient->name, 'node/' . $ingredient->link);
        }

        $units = '';
        // Print the abbreviation if recipe_unit_display says too or the abbreviation is blank (ie = Unit, which we don't print).
        if ( variable_get('recipe_unit_display', 0) == 0 || $ingredient->abbreviation == '&nbsp;') {
          $units = '<acronym ' . drupal_attributes(array('title' => recipe_unit_name($ingredient->unit_id))) . '>' . $ingredient->abbreviation . '</acronym>';
        }
        else {
          $units = recipe_unit_name($ingredient->unit_id);
        }
        $fullingredient = strlen($ingredient->note) > 0 ? $ingredient->name . ' (' . $ingredient->note . ')' : $ingredient->name;
        $output .= '<tr><td class="qty">' . $ingredient->quantity . '</td><td class="units">' . $units . '</td><td class="ingredient">' . $fullingredient . '</td></tr>';
      }
    }
    $output .= '</table>';
  }
  return $output;
}


function theme_recipe_summary($variables) {
  $node = $variables['node'];
  $show_title = isset($variables['show_title']) ? $variables['show_title'] : FALSE;
  $show_yield_form = isset($variables['show_yield_form']) ? $variables['show_yield_form'] : TRUE;
  // Construct the summary
  $output = '<table>';

  // Render the yield.
  $output .= '<tr><th class="summary-title">' . t('Yield') . '</th><td class="summary-data">' . drupal_render(drupal_get_form('recipe_yield_form', $node, $show_yield_form)) . '</td></tr>';

  if ($node->recipe->source) {
    $output .= '<tr><th>' . t('Source') . '</th><td>' . $node->recipe->source . '</td></tr>';
  }
  if ($node->recipe->preptime) {
    if ($node->recipe->preptime < 60) {
      $node->recipe->preptime = format_plural($node->recipe->preptime, '1 minute', '@count minutes');
    }
    elseif ($node->recipe->preptime % 60 == 0) {
      $node->recipe->preptime = format_plural($node->recipe->preptime / 60, '1 hour', '@count hours');
    }
    else {
      $node->recipe->preptime = t('!time hours', array('!time' => recipe_ingredient_quantity_from_decimal($node->recipe->preptime / 60)));
    }
    $output .= '<tr><th>' . t('Prep time') . '</th><td>' . $node->recipe->preptime . '</td></tr>';
  }

/*
  $vocabs = taxonomy_get_vocabularies('recipe');
  if (count($vocabs) > 0) {
    foreach ($vocabs as $vocab) {
      $output .= '<tr><th>' . $vocab->name . '</th><td>';
      $terms = taxonomy_node_get_terms_by_vocabulary($node, $vocab->vid);
      foreach ($terms as $term) {
        $term = array_shift($terms);
        $output .= l($term->name, 'taxonomy/term/' . $term->tid) . ' ';
      }
      $output .= '</td></tr>';
    }
  }
*/

  $output .= '</table>';
  if ( $show_title ) {
    return theme('recipe_box', array('title' => variable_get('recipe_summary_title', t('Summary')), 'content' => $output));
  }
  else {
    return $output;
  }
}


/**
 * Returns a cached array of recipe unit types
 */
function recipe_unit_options() {
  static $options;
  static $result;

  if (!isset($result)) {
    $order_by = '';
    // US measure preferred.
    if ( variable_get('recipe_preferred_system_of_measure', 0) == 0 ) {
      $order_by = 'type asc, metric asc, name';
    }
    // Metric measure preferred.
    else {
      $order_by = 'type asc, metric desc, name';
    }
    $options = array();
    $result = db_query("SELECT id, type, name, abbreviation FROM {recipe_unit} ORDER BY $order_by", array());
    foreach ($result as $record) {
      if (isset($record->type)) {
        if (!isset($options[$record->type])) {
          $options[$record->type] = array();
        }
        $options[$record->type][$record->id] = t('@name (@abbreviation)', array('@name' => $record->name, '@abbreviation' => $record->abbreviation));
      }
      else {
        $options[$record->id] = t('@name (@abbreviation)', array('@name' => $record->name, '@abbreviation' => $record->abbreviation));
      }
    }
  }

  return $options;
}

/**
 * Converts a recipe ingredient name to and ID
 */
function recipe_ingredient_id_from_name($name) {
  static $cache;

  if (!isset($cache[$name])) {
    $ingredient_id = db_query("SELECT id FROM {recipe_ingredient} WHERE LOWER(name) = :name", array(':name' => trim(strtolower($name))))->fetchField();

    if (!$ingredient_id) {
      global $active_db;
      $node_link = db_query("SELECT nid FROM {node} n WHERE title = :title;", array(':title' => $name))->fetchField();
      if (!$node_link) {
        $node_link = 0;
      }
      // Don't convert to lowercase if there is a &reg; (registered trademark symbol).
      if (variable_get('recipe_ingredient_name_normalize', 0) == 1 && !preg_match('/&reg;/', $name)) {
        $name = trim(strtolower($name));
      }

      db_insert('recipe_ingredient')
        ->fields(array(
          'name' => $name,
          'link' => $node_link,
        ))
        ->execute();
      // Get the ID that you just added.
      $ingredient_id = db_query("SELECT id FROM {recipe_ingredient} WHERE LOWER(name) = :name", array(':name' => trim(strtolower($name))))->fetchField();
    }
    $cache[$name] = $ingredient_id;
  }

  return $cache[$name];
}

/**
 * Converts an ingredient's quantity from decimal to fraction
 */
function recipe_ingredient_quantity_from_decimal($ingredient_quantity, $edit_mode=FALSE) {
  if (strpos($ingredient_quantity, '.') && variable_get('recipe_fraction_display', t('{%d} %d&frasl;%d'))) {
    $decimal = abs($ingredient_quantity);
    $whole = floor($decimal);
    $numerator = 0;
    $denominator = 1;
    $top_heavy = 0;

    $power = 1;
    $flag = 0;
    while ($flag == 0) {
      $argument = $decimal * $power;
      if ($argument == floor($argument)) {
        $flag = 1;
      }
      else {
        $power = $power * 10;
      }
    }


    // We have to workaround for repeating, non-exact decimals for thirds, sixths, ninths, twelfths.
    $overrides = array(
      '3333' => array(1, 3), '6666' => array(2, 3), '9999' => array(3, 3), // thirds
      '1666' => array(1, 6), '8333' => array(5, 6), // sixths
      '1111' => array(1, 9), '2222' => array(2, 9), '4444' => array(4, 9), '5555' => array(5, 9), '7777' => array(7, 9), '8888' => array(8, 9), // ninths
      '0833' => array(1, 12), '4166' => array(5, 12), '5833' => array(7, 12), '9166' => array(11, 12), // twelfths
    );
    // truncate the whole part to get just the fractional part
    $conversionstr = substr((string) ($decimal - floor($decimal)), 2, 4);
    if (array_key_exists($conversionstr, $overrides)) {
      if ($overrides[$conversionstr][0] == $overrides[$conversionstr][1]) {
          return ($whole + 1);
      }
      $denominator = $overrides[$conversionstr][1];
      $numerator   = (floor($decimal) * $denominator) + $overrides[$conversionstr][0];
    }
    else {
      $numerator = $decimal * $power;
      $denominator = $power;
    }


    // repeating decimals have been corrected
    $gcd = greatest_common_divisor($numerator, $denominator);

    $numerator = $numerator/$gcd;
    $denominator = $denominator/$gcd;
    $top_heavy = $numerator;

    $numerator = abs($top_heavy) - (abs($whole) * $denominator);

    $ingredient_quantity = sprintf(variable_get('recipe_fraction_display', t('{%d} %d&frasl;%d')), $whole, $numerator, $denominator);

    if (($whole == 0) && (strpos($ingredient_quantity, '{') >= 0)) {
      // Remove anything in curly braces.
      $ingredient_quantity = preg_replace('/{.*}/', '', $ingredient_quantity);
    }
    else {
      // Remove just the curly braces, but keep everything between them.
      $ingredient_quantity = preg_replace('/{|}/', '', $ingredient_quantity);
    }

    // In edit mode we don't want to show html tags like <sup> and <sub>.
    if ( $edit_mode ) {
      $ingredient_quantity = strip_tags($ingredient_quantity);
    }
  }

  return filter_xss_admin(trim($ingredient_quantity));
}

/**
 * Find the greatest common divisor
 */
function greatest_common_divisor($a, $b) {
  while ( $b != 0) {
    $remainder = $a % $b;
    $a = $b;
    $b = $remainder;
  }
  return abs($a);
}


/**
 * Converts an ingredient's quantity from fractions to decimal.
 */
function recipe_ingredient_quantity_from_fraction($ingredient_quantity) {

  // Replace a dash separated fraction with a ' ' to normalize the input string.
  $ingredient_quantity = preg_replace('/^(\d+)[\-](\d+)[\/](\d+)/', '${1} ${2}/${3}', $ingredient_quantity);

  if ($pos_slash = strpos($ingredient_quantity, '/')) {
    $pos_space = strpos($ingredient_quantity, ' ');

    // Can't trust $pos_space to be a zero value if there is no space
    // so set it explicitly.
    if ($pos_space === FALSE) {
      $pos_space = 0;
    }

    $whole = substr($ingredient_quantity, 0, $pos_space);
    $numerator = substr($ingredient_quantity, $pos_space, $pos_slash);
    $denominator = substr($ingredient_quantity, $pos_slash + 1);
    $ingredient_quantity = $whole+($numerator/$denominator);
  }

  return $ingredient_quantity;
}


/**
 * Loads the ingredients for a recipe
 */
function recipe_load_ingredients($nid) {
  $select = db_select('recipe_node_ingredient', 'ri');
  $select->join('recipe_ingredient', 'i', 'ri.ingredient_id = i.id');
  $select->join('recipe_unit', 'u', 'ri.unit_id = u.id');
  $select->addField('ri', 'id', 'ri_id');
  $select->addField('i', 'name');
  $select->addField('ri', 'note');
  $select->addField('i', 'link');
  $select->addField('ri', 'quantity');
  $select->addField('ri', 'unit_id');
  $select->addField('ri', 'weight');
  $select->addField('u', 'abbreviation');
  $select->addField('ri', 'ingredient_id');
  $select->condition('ri.nid', $nid);
  $select->orderBy('ri.weight', 'ASC');

  $ingredients = array();
  $result = $select->execute()->fetchAll(PDO::FETCH_ASSOC);
  foreach ($result as $record) {
    $ingredients[] = $record;
  }

  return $ingredients;
}

/**
 * Converts a recipe unit ID to it's abbreviation
 */
function recipe_unit_abbreviation($unit_id) {
  static $abbreviations;

  if (!$abbreviations) {
    $rs = db_query("SELECT id, abbreviation FROM {recipe_unit}");
    foreach ($rs as $unit) {
      $abbreviations[$unit->id] = $unit->abbreviation;
    }
  }

  return $abbreviations[$unit_id];
}

/**
 * Converts a recipe unit ID to it's name */
function recipe_unit_name($unit_id) {
  static $unit_names;

  if (!$unit_names) {
    $rs = db_query("SELECT id, name FROM {recipe_unit}");
    foreach ($rs as $unit) {
      $unit_names[$unit->id] = $unit->name;
    }
  }

  return $unit_names[$unit_id];
}


/**
 * Menu callback; Generates various representation of a recipe page with
 * all descendants and prints the requested representation to output.
 *
 * @param type
 *   - a string encoding the type of output requested.
 * @param nid
 *   - an integer representing the node id (nid) of the node to export
 */
function recipe_export($type = 'html', $nid = NULL, $yield = NULL) {
  // normalize typed urls
  $type = drupal_strtolower($type);

  // load supported formats
  $formats = module_invoke_all('recipeio', 'export_single');
  $perm = isset($formats[$type]['access arguments']) ? $formats[$type]['access arguments'] : 'export recipes';
  if (!user_access($perm)) {
    drupal_access_denied();
    return;
  }

  // If callback exists, call it, otherwise error out.
  if (isset($formats[$type]) && function_exists($formats[$type]['callback'])) {
    echo call_user_func($formats[$type]['callback'], $nid, $yield);
  }
  else {
    drupal_set_message(t('Unknown export format(%the_format).', array('%the_format' => $type)), 'error');
    drupal_not_found();
  }
}


/**
 * Callback function for ingredient autocomplete
 */
function recipe_autocomplete_page($string = "", $limit = 10) {
  $matches = array();
  $result = db_query("SELECT name FROM {recipe_ingredient} WHERE LOWER(name) LIKE :name ORDER BY name LIMIT $limit", array(':name' => strtolower($string) . '%'));
  foreach ($result as $record) {
    $matches[$record->name] = check_plain($record->name);
  }
  drupal_json_output($matches);
  exit();
}

/**
 * Implementation of hook_validate().
 *
 * Errors should be signaled with form_set_error().
 */
function recipe_validate($node, &$form) {

  if (!is_numeric($node->yield) || $node->yield <=0) {
    form_set_error('yield', t('Yield must be a valid positive integer.'));
  }
}

/**
 * Converts an ingredients name string to an ingredient object.
 */
function recipe_parse_ingredient_string($ingredient_string) {
  if (preg_match('#([0-9.]+(?:\s?\d*/\d*)?\s?)?(?:([a-zA-Z.]*)\s)?(.*)#', trim($ingredient_string), $matches)) {
    $ingredient->name = $matches[3];
    $ingredient->quantity = trim($matches[1]);
    if ($ingredient->quantity == 0) {
      $ingredient->quantity = 0;
    }
    $t_unit = $matches[2];
    $unit = recipe_unit_from_name($t_unit);

    if ($unit) {
      $ingredient->unit_id = $unit->id;
      $ingredient->abbreviation = $unit->abbreviation;
    }
    else {
      $ingredient->unit_id = 29;
      $ingredient->abbreviation = '';
      $ingredient->name = $t_unit . ' ' . $ingredient->name;
    }

    $ingredient->name = trim($ingredient->name);

    return $ingredient;
  }
  else {
    return FALSE;
  }
}

/**
 * Returns information about a unit based on a unit abbreviation or name
 */
function recipe_unit_from_name($name) {
  if (strlen($name) > 1)
    $string = strtolower($name);
  else
    $string = $name;
  $ending = substr($string, -1, 1);
  if ($ending == 's'  && $string != 'ds' || $ending == '.') {
    $string = substr($string, 0, strlen($string) -1);
  }
  $ending = substr($string, -1, 1);
  if ($ending == 's'  && $string != 'ds'|| $ending == '.') {
    $string = substr($string, 0, strlen($string) -1);
  }

  static $units_array;

  if (!$units_array) {
    $rs = db_query("SELECT id, name, abbreviation FROM {recipe_unit}");
    foreach ($rs as $unit) {
      $units_array[strtolower($unit->name)] = $unit;
      $units_array[$unit->abbreviation] = $unit;
    }
  }

  return $units_array[$string];
}


/**
 * All recipe fields should be run through one of the drupal data checks.
 */
function recipe_node_sanitize($node) {

  $node->format = 'filtered_html';

  $node->recipe->instructions = check_markup($node->recipe->instructions, $node->format, FALSE);
  if ($node->recipe->notes) {
    $node->recipe->notes = check_markup($node->recipe->notes, $node->format, FALSE);
  }
  if ($node->recipe->source) {
    $node->recipe->source = check_markup($node->recipe->source, $node->format, FALSE);
  }
  if ($node->recipe->ingredients) {
    $tmp = $node->recipe->ingredients;
    $node->recipe->ingredients = array();
    foreach ($tmp as $ingredient) {
      // For preview, node->ingredients is an array, for actual display, it's an object
      if (is_array($ingredient)) {
        if (isset($ingredient['name'])) {
          $ingredient['name'] = filter_xss($ingredient['name'], array());
        }
        if (isset($ingredient['note'])) {
          $ingredient['note'] = filter_xss($ingredient['note']);
        }
      }
      elseif (is_object($ingredient)) {
        if (isset($ingredient->name)) {
          $ingredient->name = filter_xss($ingredient->name, array());
        }
        if (isset($ingredient->note)) {
          $ingredient->note = filter_xss($ingredient->note);
        }
      }
      $node->recipe->ingredients[] = $ingredient;
    }
  }

  return $node;
}


/*
 * If there is an ingredient with the same name as a node type ingredient, link them.
 */
function recipe_node_update($node) {
  if ($node->type == 'ingredient') {
    db_query("UPDATE {recipe_ingredient} SET link = :link WHERE LOWER(name) = :name", array(':link' => $node->nid, ':name' => trim(strtolower($node->title))));
  }
}
function recipe_node_insert($node) {
  if ($node->type == 'ingredient') {
    recipe_node_update($node);
  }
}


function recipe_yield_form($form, &$form_state, $node, $show_yield_form) {
  // Don't render the custom yield textbox and submit buttons if disabled or shown in a block.

  if ($show_yield_form == FALSE || variable_get('recipe_summary_location', 0) == 1 ) {
    $form['yield'] = array(
      '#markup' => $node->recipe->yield,
    );
    // An html space is useful here since we don't have a separate theme function for this form.
    $form['_space'] = array(
      '#markup' => '&nbsp;',
    );
    $form['yield_unit'] = array(
      '#markup' => ($node->recipe->yield_unit == '')?t('Servings'):$node->recipe->yield_unit,
    );
  }

  // Render the custom yield textbox and submit buttons.
  else {
    $form['custom_yield'] = array(
      '#type' => 'textfield',
      '#default_value' => $node->recipe->yield,
      '#size' => 2,
      '#maxlength' => 4,
    );
    $form['yield_unit'] = array(
      '#markup' => ($node->recipe->yield_unit == '')?t('Servings'):$node->recipe->yield_unit,
    );
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Change'),
    );
    $form['reset'] = array(
      '#type' => 'submit',
      '#value' => t('Reset'),
    );
    $form['halve'] = array(
      '#type' => 'submit',
      '#value' => t('Halve'),
    );
    $form['double'] = array(
      '#type' => 'submit',
      '#value' => t('Double'),
    );
  }

  return $form;
}

/**
 * Form recipe_import_form
 */
function recipe_import_form($form_state) {

  $formats = module_invoke_all('recipeio', 'import_single');

  $options = array();
  foreach ($formats as $format) {
    $options[$format['callback']] = $format['format_name'];
  }

  if (isset($form_state['node_preview'])) {
    $form['#prefix'] = $form_state['node_preview'];
  }

  $form['recipe_format'] = array(
    '#type' => 'select',
    '#title' => t('Recipe format'),
    '#options' => $options,
    '#default_value' => $form_state['values']['recipe_format'],
    '#size' => 1,
    '#description' => t('The recipe input format.'),
  );

  $form['recipe_import_text'] = array(
    '#type' => 'textarea',
    '#title' => t('Paste import data here'),
    '#default_value' => $form_state['values']['recipe_import_text'],
    '#cols' => 55,
    '#rows' => 8,
    '#required' => TRUE,
    '#description' => t('Use 1 blank line between sections: Description, Ingredients, Instructions, Notes. Always use preview first to avoid unintended consequences.'),
  );

  $form['buttons']['preview'] = array(
    '#type' => 'submit',
    '#value' => t('Preview'),
    '#weight' => 1,
    '#submit' => array('recipe_import_form_build_preview'),
  );

  $form['buttons']['import'] = array(
    '#type' => 'submit',
    '#value' => t('Import'),
    '#weight' => 2,
    '#submit' => array('recipe_import_form_submit'),
  );

  return $form;
}


/**
 * Import preview routine that allows that users to see what actually will be imported before doing so.
 */
function recipe_import_form_build_preview($form, &$form_state) {
  drupal_add_css(drupal_get_path('module', 'recipe') . '/recipe.css');

  $parsed_recipe_object = recipe_import_parse($form, $form_state);
  if ($parsed_recipe_object != FALSE) {
    //$node = node_form_submit_build_node($form, $form_state);
    $node = recipe_import_get_node($parsed_recipe_object);
    $cloned_node = clone($node);
    $cloned_node->in_preview = TRUE;
    $form_state['node_preview'] = theme('node_preview', array('node' => $cloned_node));
    $form_state['rebuild'] = TRUE;
    drupal_set_title(t('Preview'));
  }
}


/**
 * Validate handler for the single recipe import form.
 */
function recipe_import_form_validate($form, &$form_state) {
  // Make sure that they choose an import format.
  // Otherwise the text entry is lost and the import fails with an error.
  if (empty($form_state['values']['recipe_format'])) {
    form_set_error('recipe_format', t('You must choose a recipe import format.'));
  }
}


/**
 * Submit handler for the single recipe import form.
 */
function recipe_import_form_submit($form, &$form_state) {
  global $user;
  $parsed_recipe_object = recipe_import_parse($form, $form_state);
  if ( ($node = recipe_import_get_node($parsed_recipe_object)) != FALSE ) {
    node_save($node);
    $form_state['redirect'] = 'node/' . $node->nid . '/edit';
    drupal_set_message(t('Recipe Imported'));
  }

}


/**
 * Get a node-like stdClass object suitable for node_save and preview.
 */
function recipe_import_get_node($parsed_recipe_object = FALSE) {
  global $user;
  if ($parsed_recipe_object) {
    //node stuff
    $node = new stdClass();
    $node->title = $parsed_recipe_object['title'];
    $node->description = $parsed_recipe_object['title'] . ' imported from Recipe Import';
    $node->type = 'recipe';
    $node->uid = $user->uid;
    // Promote is usually handled by a moderator.
    $node->promote = 0;
    // Let's allow comments by default.
    $node->comment = 2;

    //recipe stuff
    $node->source = $parsed_recipe_object['source'] != '' ? $parsed_recipe_object['source'] : $user->name;
    $node->yield = 1;
    $node->notes = $parsed_recipe_object['notes'];
    $node->instructions = $parsed_recipe_object['instructions'];
    $node->preptime = 60;

    //ingredients, have to change them into node->ingredients format
    $ingredient_list = array();
    foreach ($parsed_recipe_object['ingredients'] as $i) {
      $ingredient = new stdClass();
      $ingredient->quantity = $i['quantity'];
      if ($i['unit_obj'] != FALSE) {
        $ingredient->unit_id = $i['unit_obj']->id;
      }
      $ingredient->name = $i['ingredient_name'];
      $ingredient->note = $i['ingredient_note'];

      $ingredient_list[] = $ingredient;
    }
    $node->ingredients = $ingredient_list;
    return $node;
  }
  return FALSE;
}


/**
 * Import parsing controller which loads the actual parsing instances based on recipe_format.
 *
 * All parser instances should return a $recipe object that looks like this:
 *
 * $recipe = array(
 *   'title' => 'recipe title string',
 *   'ingredients' => array of ingredients items(below);
 *   'instuctions' => 'string of instructions'
 * );
 *
 * ingredients items = array(
 *    'quantity' =>
 *    'ingredient_name' =>
 *    'unit_name' =>
 *    'unit_obj' => stdClass, comes from database lookup: see recipe_unit_fuzzymatch().  ==FALSE if no-match
 *    'ingre_obj' => comes from database lookup: see recipe_ingredient_match().  ==FALSE if no-match
 * );
 *
 */
function recipe_import_parse($form, &$form_state) {
  $import_function = $form_state['values']['recipe_format'];
  $text = $form_state['values']['recipe_import_text'];

  $recipe = array();
  if (function_exists($import_function)) {
    $recipe = call_user_func($import_function, $text);
    return $recipe;
  }
  else {
    drupal_set_message(t('Recipe import function does not exist(%the_function)', array('%the_function' => $import_function)), 'error');
    return FALSE;
  }
}


/**
 * Fetch a recipe_unit.
 *
 * @param $recipe_name_or_abbrev
 *   A string representing a unit of measure abbreviation or a unit name.
 * @return
 *   A recipe_unit stdClass upon successful load or FALSE
 */
function recipe_unit_fuzzymatch($recipe_name_or_abbrev, $reset = FALSE) {
  static $units;

  // Empty strings should use the default non-printing 'Unit'.
  if ( $recipe_name_or_abbrev == '' ) {
    $recipe_name_or_abbrev = 'Unit';
  }

  if (!isset($units) || $reset) {
    // Get all units to prepare for fuzzy match.
    $units = array();
    $order_by = '';
    // US measure preferred.
    if ( variable_get('recipe_preferred_system_of_measure', 0) == 0 ) {
      $order_by = 'order by metric asc';
    }
    // Metric measure preferred.
    else {
      $order_by = 'order by metric desc';
    }
    $result = db_query("SELECT id, name, abbreviation, aliases FROM {recipe_unit} :order_by", array(':order_by' => $order_by));
    foreach ($result as $row) {
      $units[] = $row;
    }
  }

  // First pass unit case must match exactly( T=Tbsp, t=tsp ).
  foreach ($units as $u) {
    $pats = array();
    // Add name pattern.
    $pats[] = '^' . $u->name . 's{0,1}$';
    // Add abbreviation pattern.
    $pats[] = '^' . $u->abbreviation . 's{0,1}\.{0,1}$';
    // Add comma separated alias patterns.
    $aliases = explode(',', $u->aliases);
    foreach ($aliases as $alias) {
      $pats[] = '^' . trim($alias) . 's{0,1}\.{0,1}$';
    }
    $search_pat = implode('|', $pats);
    if (preg_match("/$search_pat/", $recipe_name_or_abbrev)) {
      return $u;
    }
  }

  // Second pass unit case doesn't matter.
  foreach ($units as $u) {
    $pats = array();
    // Add name pattern.
    $pats[] = '^' . $u->name . 's{0,1}$';
    // Add abbreviation pattern.
    $pats[] = '^' . $u->abbreviation . 's{0,1}\.{0,1}$';
    // Add comma separated alias patterns.
    $aliases = explode(',', $u->aliases);
    foreach ($aliases as $alias) {
      $pats[] = '^' . trim($alias) . 's{0,1}\.{0,1}$';
    }
    $search_pat = implode('|', $pats);
    if (preg_match("/$search_pat/i", $recipe_name_or_abbrev)) {
      return $u;
    }
  }

  return FALSE;
}


/**
 * Fetch an ingredient.
 *
 * @param $recipe_ingredient_name
 *   A string representing a recipe_ingredient_name.
 * @return
 *   A recipe_ingredient array upon successful load or FALSE
 */
function recipe_ingredient_match($recipe_ingredient_name) {
  $result = db_query("SELECT id, name FROM {recipe_ingredient} where name='%s'", $recipe_ingredient_name);
  foreach ($result as $row) {
    return array(
      'id' => $row->id,
      'name' => $row->name
    );
  }
  return FALSE;
}


/**
 * Extend user_access to handle case where no import formats are available
 */
function recipe_import_myaccess($string, $account = NULL, $reset = FALSE) {

  // short circuit if there are no parsers available.
  $formats = module_invoke_all('recipeio', 'import_single');
  if (count($formats) == 0) {
    return FALSE;
  }
  // we have a format so continue to user_access
  return user_access($string, $account, $reset);
}


/**
 * Extend user_access to handle case where no export formats are available
 */
function recipe_export_multi_myaccess($string, $account = NULL, $reset = FALSE) {

  // short circuit if there are no parsers available.
  $formats = module_invoke_all('recipeio', 'export_multi');
  if (count($formats) == 0) {
    return FALSE;
  }
  // we have a format so continue to user_access
  return user_access($string, $account, $reset);
}


/**
 * Extend user_access to handle case where no import formats are available
 */
function recipe_import_multi_myaccess($string, $account = NULL, $reset = FALSE) {

  // short circuit if there are no parsers available.
  $formats = module_invoke_all('recipeio', 'import_multi');
  if (count($formats) == 0) {
    return FALSE;
  }
  // we have a format so continue to user_access
  return user_access($string, $account, $reset);
}


/**
 * Get the latest recipes by created date.
 *
 * @return
 *   A database query result suitable for use the node_title_list.
 */
function recipe_get_latest($count = 0) {
  $select = db_select('node', 'n');
  $select->addField('n', 'nid');
  $select->addField('n', 'title');
  $select->addField('n', 'sticky');
  $select->addField('n', 'created');
  $select->condition('n.type', 'recipe');
  $select->condition('n.status', 1);
  $select->orderBy('n.sticky', 'DESC');
  $select->orderBy('n.created', 'DESC');
  $select->range(0, $count);
  return $select->execute();
}


function strip_html_and_encode_entities($string) {
  $string = filter_xss($string, array());
  $string = str_replace("&deg;", "\xB0", $string);
  return $string;
}


/**
 * Implementation of hook_views_api for Views integration.
 */
function recipe_views_api() {
 return array(
   'api' => 2,
   'path' => drupal_get_path('module', 'recipe'),
 );
}


/**
 * Implementation of hook_field_extra_fields().
 * This adds these fields to the manage fields UI for changing weights.
 */
function recipe_field_extra_fields() {

  $extra = array();
  $extra['node']['recipe'] = array(
    'form' => array(
      'summary_box' => array(
        'label' => t('Summary Box'),
        'description' => t('Recipe module form.'),
        'weight' => -6,
      ),
      'description' => array(
        'label' => t('Description'),
        'description' => t('Recipe module form.'),
        'weight' => -5,
      ),
      'yield' => array(
        'label' => t('Yield'),
        'description' => t('Recipe module form.'),
        'weight' => -4,
      ),
      'yield_unit' => array(
        'label' => t('Yield units'),
        'description' => t('Recipe module form.'),
        'weight' => -4,
      ),
      'ingredients' => array(
        'label' => t('Ingredients'),
        'description' => t('Recipe module form.'),
        'weight' => -3,
      ),
      'instructions' => array(
        'label' => t('Instructions'),
        'description' => t('Recipe module form.'),
        'weight' => -2,
      ),
      'notes' => array(
        'label' => t('Additional notes'),
        'description' => t('Recipe module form.'),
        'weight' => -2,
      ),
      "source" => array(
        'label' => t('Source'),
        'description' => t('Recipe module form.'),
        'weight' => -2,
      ),
      'preptime' => array(
        'label' => t('Preparation time'),
        'description' => t('Recipe module form.'),
        'weight' => -1,
      ),
    ),
  );

  return $extra;
}


function recipe_content_extra_field_weight($pseudo_field_name) {
  if (function_exists('content_extra_field_weight')) {
    return content_extra_field_weight('recipe', $pseudo_field_name);
  }
  else {
    $recipe_fields = recipe_field_extra_fields();
    if ( isset($recipe_fields['node']['recipe']['form'][$pseudo_field_name]['weight']) ) {
      return $recipe_fields['node']['recipe']['form'][$pseudo_field_name]['weight'];
    }
    else {
      return 0;
    }
  }
}


function theme_recipe_box($variables) {
  $output = '<h2 class="title">' . $variables['title'] . '</h2><div>' . $variables['content'] . '</div>';
  return $output;
}


/**
 * $ingredient_list may be an array of objects or an array of array elements.

function _in_array($ingredient_object, $ingredient_list) {
  foreach ($ingredient_list as $i) {
    $i_name = '';
    if (is_array($i)) {
      $i_name = trim(strtolower($i['name']));
    }
    else {
      $i_name = trim(strtolower($i->name));
    }
    if (strtolower($ingredient_object->name) === $i_name) {
      return TRUE;
    }
  }
  return FALSE;
}
*/
