<?php
/**
 * @file
 * Contains functions for Recipe node CRUD and display.
 */

use \Drupal\Core\Entity\EntityInterface;
use \Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use \Drupal\Core\Form\FormStateInterface;
use \Drupal\Core\Routing\RouteMatchInterface;
use \Drupal\field\FieldConfigInterface;

/**
 * Implements hook_help().
 */
function recipe_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'recipe.settings':
      return t('Configure the management and display of recipes.');
  }
}

/**
 * Implements hook_theme().
 */
function recipe_theme($existing, $type, $theme, $path) {
  return array(
    'recipe_duration' => array(
      'variables' => array('duration' => 0),
    ),
    'recipe_total_time' => [
      'variables' => ['total_time' => 0, 'label' => t('Total time'), 'label_display' => 'above'],
    ],
    'recipe_yield' => [
      'variables' => ['yield' => '', 'label' => t('Yield'), 'label_display' => 'above'],
    ],
  );
}

/**
 * Implements hook_permission().
 */
function recipe_permission() {
  return array(
    'export recipes' => array(
      'title' => t('Export recipes'),
      'description' => t('Export recipes in various formats.'),
    ),
    'import recipes' => array(
      'title' => t('Import recipes'),
      'description' => t('Import recipes in various formats.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function recipe_menu() {
  // Add a tab on the recipe add screen for Recipe Import.
  // Need to add 'file path' because some modules render node/add/recipe/std
  // even though they shouldn't.
  $items['node/add/recipe/std'] = array(
    'title' => 'Standard entry',
    'weight' => 0,
    'file path' => drupal_get_path('module', 'node'),
    'type' => MENU_DEFAULT_LOCAL_TASK
  );
  $items['node/add/recipe/import'] = array(
    'title' => 'Recipe Import',
    'description' => 'Allows you to create a recipe by pasting various formats into a big text box.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('recipe_import_form'),
    'access callback' => 'recipe_import_myaccess',
    'access arguments' => array('import recipes'),
    'file' => 'recipe.admin.inc',
    'weight' => 1,
    'type' => MENU_LOCAL_TASK
  );
  $items['recipe/export'] = array(
    'page callback' => 'recipe_export',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),  // lower level permissions are handled in recipe_export
    'file' => 'recipe.pages.inc',
  );
  $items['admin/structure/recipe'] = array(
    'title' => 'Recipe bulk import/export',
    'description' => 'Export/Import all recipes from this site to/from a supported format.',
    'page callback' => 'recipe_export_multi',
    'access callback' => 'recipe_export_multi_myaccess',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'recipe.admin.inc',
  );
  $items['admin/structure/recipe/export_multi'] = array(
    'title' => 'Recipe bulk export',
    'description' => 'Export all recipes from this site into a supported output format.',
    'type' => MENU_DEFAULT_LOCAL_TASK | MENU_LOCAL_TASK,
  );
  $items['admin/structure/recipe/import_multi'] = array(
    'title' => 'Recipe bulk import',
    'description' => 'Import all recipes from this site into a supported output format.',
    'page callback' => 'recipe_import_multi',
    'access callback' => 'recipe_import_multi_myaccess',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'recipe.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for 'field_config_edit_form'.
 */
function recipe_form_field_config_edit_form_alter(&$form, FormStateInterface $form_state) {
  $field = $form_state->getFormObject()->getEntity();

  if ($field->getTargetBundle() == 'recipe' && $field->getType() == 'integer') {
    $form['third_party_settings']['recipe']['total_time'] = [
      '#type' => 'checkbox',
      '#title' => t("Add this field's value to the Recipe's total time."),
      '#default_value' => $field->getThirdPartySetting('recipe', 'total_time', 0),
    ];
  }
}

/**
 * Implements hook_ENTITY_TYPE_view().
 */
function recipe_node_view(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) {
  $config = \Drupal::config('recipe.settings');

  // Calculate the total time required to make the recipe.
  $total_time = 0;
  foreach ($entity->getFieldDefinitions() as $field_name => $field_definition) {
    if (!($field_definition instanceof FieldConfigInterface)) {
      continue;
    }
    if ($field_definition->getType() == 'integer' && $field_definition->getThirdPartySetting('recipe', 'total_time') == 1) {
      $total_time += $entity->{$field_name}->value;
    }
  }
  $build['recipe_total_time'] = [
    '#theme' => 'recipe_total_time',
    '#label' => $config->get('total_time.label'),
    '#label_display' => $config->get('total_time.label_display'),
    '#total_time' => ['#theme' => 'recipe_duration', '#duration' => $total_time],
  ];

  // Display the recipe yield by combining the recipe_yield_amount and
  // recipe_yield_unit fields.
  $arguments = [
    '@yield_amount' => $entity->recipe_yield_amount->value,
    '@yield_unit' => $entity->recipe_yield_unit->value,
  ];
  $build['recipe_yield'] = [
    '#theme' => 'recipe_yield',
    '#label' => $config->get('yield.label'),
    '#label_display' => $config->get('yield.label_display'),
    '#yield' => t('@yield_amount @yield_unit', $arguments),
  ];
  /*if ( isset($node->in_preview) && $node->in_preview == 1 ) {
    return;
  }

  if ($node->type == 'recipe' && $view_mode != 'rss' && $view_mode != 'teaser') {
    $formats = module_invoke_all('recipeio', 'export_single');
    $links = array();
    foreach ($formats as $key => $format) {
      $perm = isset($format['access arguments']) ? $format['access arguments'] : 'export recipes';
      if (user_access($perm)) {
        $links[$key] = array(
          'title' => $format['format_name'],
          'href' => "recipe/export/$key/$node->nid/" . $node->recipe_yield,
          'attributes' => array('title' => $format['format_help']),
        );
      }
    }

    if (!empty($links)) {
      array_unshift($links, array('title' => '<br/>' . t('Export to') . ':', 'html' => TRUE));
      $node->content['links']['recipe'] = array(
        '#theme' => 'links__recipe__node',
        '#links' => $links,
        '#attributes' => array('class' => array('links', 'inline')),
      );
    }
  }*/
}

/**
 * Prepares variables for the recipe_total_time template.
 *
 * Default template: recipe_total_time.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - total_time: The content of the pseudo-field.
 *   - label: A string containing the pseudo-field's title.
 *   - label_display: The display settings for the label.
 */
function template_preprocess_recipe_total_time(&$variables, $hook) {
  // Add the RDF metadata to the content_attributes.
  $mapping = [
    'properties' => ['schema:totalTime'],
    'datatype' => 'xsd:duration',
    'datatype_callback' => ['callable' => 'recipe_duration_iso8601'],
  ];
  $variables['content_attributes'] = rdf_rdfa_attributes($mapping, $variables['total_time']['#duration']);

  $variables['label_hidden'] = ($variables['label_display'] == 'hidden');
}

/**
 * Prepares variables for the recipe_yield template.
 *
 * Default template: recipe_yield.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - yield: The content of the pseudo-field.
 *   - label: A string containing the pseudo-field's title.
 *   - label_display: The display settings for the label.
 */
function template_preprocess_recipe_yield(&$variables, $hook) {
  // Add the RDF metadata to the content_attributes.
  $mapping = [
    'properties' => ['schema:recipeYield'],
  ];
  $variables['content_attributes'] = rdf_rdfa_attributes($mapping);

  $variables['label_hidden'] = ($variables['label_display'] == 'hidden');
}

/**
 * Extends user_access to handle the case where no import formats are available.
 */
function recipe_import_myaccess($string, $account = NULL, $reset = FALSE) {
  // short circuit if there are no parsers available.
  $formats = module_invoke_all('recipeio', 'import_single');
  if (count($formats) == 0) {
    return FALSE;
  }
  // we have a format so continue to user_access
  return user_access($string, $account, $reset);
}

/**
 * Extends user_access to handle the case where no export formats are available.
 */
function recipe_export_multi_myaccess($string, $account = NULL, $reset = FALSE) {
  // short circuit if there are no parsers available.
  $formats = module_invoke_all('recipeio', 'export_multi');
  if (count($formats) == 0) {
    return FALSE;
  }
  // we have a format so continue to user_access
  return user_access($string, $account, $reset);
}

/**
 * Extends user_access to handle the case where no import formats are available.
 */
function recipe_import_multi_myaccess($string, $account = NULL, $reset = FALSE) {
  // short circuit if there are no parsers available.
  $formats = module_invoke_all('recipeio', 'import_multi');
  if (count($formats) == 0) {
    return FALSE;
  }
  // we have a format so continue to user_access
  return user_access($string, $account, $reset);
}

/**
 * Sanitizes a string and encodes the &deg; symbol.
 */
function strip_html_and_encode_entities($string) {
  $string = filter_xss($string, array());
  $string = str_replace("&deg;", "\xB0", $string);
  return $string;
}

/**
 * Implements hook_entity_extra_field_info().
 */
function recipe_entity_extra_field_info() {
  $extra = [];

  $extra['node']['recipe']['display']['recipe_total_time'] = [
    'label' => t('Total time'),
    'description' => t('The total time required to make the recipe.'),
    'weight' => -1,
    'visible' => TRUE,
  ];
  $extra['node']['recipe']['display']['recipe_yield'] = [
    'label' => t('Yield'),
    'description' => t('The amount of food produced by the recipe.'),
    'weight' => -4,
    'visible' => TRUE,
  ];

  return $extra;
}

/**
 * Checks a string for ISO-8859-1 chars and encodes them to UTF-8.
 *
 * @param string $in_str
 *   A string with possible ISO-8859-1 chars.
 * @return string
 *   A UTF8 string representation of $in_str.
 */
function fixEncoding($in_str) {
  $cur_encoding = mb_detect_encoding($in_str) ;
  if ($cur_encoding == "UTF-8" && mb_check_encoding($in_str, "UTF-8")) {
    return $in_str;
  }
  else {
    return utf8_encode($in_str);
  }
}

function template_preprocess_recipe_duration(&$variables) {
  $hours = floor($variables['duration'] / 60);
  $minutes = $variables['duration'] % 60;
  $variables['hours'] = '';
  $variables['minutes'] = '';
  if ($hours > 0) {
    $variables['hours'] = \Drupal::translation()->formatPlural($hours, '1 hour', '@count hours');
  }
  if ($minutes > 0 || $variables['duration'] == 0) {
    $variables['minutes'] = \Drupal::translation()->formatPlural($minutes, '1 minute', '@count minutes');
  }
}

/**
 * Returns a duration string in ISO 8601 format.
 *
 * @param $duration
 *   An integer or array with 'value' element representing a time duration.
 * @return string
 *   A string representing a time duration in ISO 8601 format.
 */
function recipe_duration_iso8601($duration = 0) {
  if (is_array($duration) && isset($duration['value'])) {
    $duration = $duration['value'];
  }
  $hours = floor($duration / 60);
  $minutes = $duration % 60;
  $output = '';
  if ($hours > 0) {
    $output .= $hours . 'H';
  }
  if ($minutes > 0) {
    $output .= $minutes . 'M';
  }
  return empty($output) ? 'PT0M' : 'PT' . $output;
}
