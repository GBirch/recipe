<?php

/**
 * @file
 * Contains basic functions for the Ingredient module.
 */

use Drupal\Component\Utility\Xss;
use Drupal\Core\Render\Element;
use Drupal\ingredient\Entity\Ingredient;

/**
 * Implements hook_theme().
 */
function ingredient_theme($existing, $type, $theme, $path) {
  return array(
    'ingredient' => array(
      'render element' => 'elements',
    ),
    'ingredient_formatter' => array(
      'variables' => array('name' => NULL, 'quantity' => 0, 'unit_name' => '', 'unit_abbreviation' => '', 'unit_display' => 0, 'note' => ''),
    ),
  );
}

/**
 * Prepares variables for ingredient templates.
 *
 * Default template: ingredient.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - elements: An associative array containing the ingredient and any fields
 *     attached to the ingredient. Properties used:
 *     - #fields: A \Drupal\ingredient\IngredientInterface object.
 *     - #view_mode: The current view mode for this ingredient, e.g.'full' or
 *       'teaser'.
 *   - attributes: HTML attributes for the containing element.
 */
function template_preprocess_ingredient(&$variables) {
  $variables['view_mode'] = $variables['elements']['#view_mode'];
  $variables['ingredient'] = $variables['elements']['#ingredient'];
  /** @var \Drupal\ingredient\IngerdientInterface $ingredient */
  $ingredient = $variables['ingredient'];

  $variables['url'] = $ingredient->url();
  // We use name here because that is what appears in the UI.
  $variables['name'] = $variables['elements']['name'];
  unset($variables['elements']['name']);
  $variables['page'] = $variables['view_mode'] == 'full' && ingredient_is_page($ingredient);

  // Helpful $content variable for templates.
  $variables['content'] = array();
  foreach (Element::children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }
}

/**
 * Returns whether the current page is the page of the passed-in ingredient.
 *
 * @param \Drupal\ingredient\Entity\Ingredient $ingredient
 *   A ingredient entity.
 */
function ingredient_is_page(Ingredient $ingredient) {
  if (\Drupal::routeMatch()->getRouteName() == 'entity.ingredient.canonical' && $page_id = \Drupal::routeMatch()->getRawParameter('ingredient')) {
    return $page_id == $ingredient->id();
  }
  return FALSE;
}


/**
 * Converts an ingredient's quantity from decimal to fraction.
 */
function ingredient_quantity_from_decimal($ingredient_quantity, $fraction_format = '{%d} %d&frasl;%d', $edit_mode = FALSE) {
  if (strpos($ingredient_quantity, '.')) {
    $decimal = abs($ingredient_quantity);
    $whole = floor($decimal);
    $numerator = 0;
    $denominator = 1;
    $top_heavy = 0;

    $power = 1;
    $flag = 0;
    while ($flag == 0) {
      $argument = $decimal * $power;
      if ($argument == floor($argument)) {
        $flag = 1;
      }
      else {
        $power = $power * 10;
      }
    }

    // We have to workaround for repeating, non-exact decimals for thirds, sixths, ninths, twelfths.
    $overrides = array(
      '3333' => array(1, 3), '6666' => array(2, 3), '9999' => array(3, 3), // thirds
      '1666' => array(1, 6), '8333' => array(5, 6), // sixths
      '1111' => array(1, 9), '2222' => array(2, 9), '4444' => array(4, 9), '5555' => array(5, 9), '7777' => array(7, 9), '8888' => array(8, 9), // ninths
      '0833' => array(1, 12), '4166' => array(5, 12), '5833' => array(7, 12), '9166' => array(11, 12), // twelfths
    );
    // truncate the whole part to get just the fractional part
    $conversionstr = substr((string) ($decimal - floor($decimal)), 2, 4);
    if (array_key_exists($conversionstr, $overrides)) {
      if ($overrides[$conversionstr][0] == $overrides[$conversionstr][1]) {
          return ($whole + 1);
      }
      $denominator = $overrides[$conversionstr][1];
      $numerator   = (floor($decimal) * $denominator) + $overrides[$conversionstr][0];
    }
    else {
      $numerator = $decimal * $power;
      $denominator = $power;
    }

    // repeating decimals have been corrected
    $gcd = ingredient_greatest_common_divisor($numerator, $denominator);

    $numerator = $numerator/$gcd;
    $denominator = $denominator/$gcd;
    $top_heavy = $numerator;

    $numerator = abs($top_heavy) - (abs($whole) * $denominator);

    $ingredient_quantity = sprintf($fraction_format, $whole, $numerator, $denominator);

    if (($whole == 0) && (strpos($ingredient_quantity, '{') >= 0)) {
      // Remove anything in curly braces.
      $ingredient_quantity = preg_replace('/{.*}/', '', $ingredient_quantity);
    }
    else {
      // Remove just the curly braces, but keep everything between them.
      $ingredient_quantity = preg_replace('/{|}/', '', $ingredient_quantity);
    }

    // In edit mode we don't want to show html tags like <sup> and <sub>.
    if ( $edit_mode ) {
      $ingredient_quantity = strip_tags($ingredient_quantity);
    }
  }

  return Xss::filterAdmin(trim($ingredient_quantity));
}

/**
 * Finds the greatest common divisor of two numbers.
 */
function ingredient_greatest_common_divisor($a, $b) {
  while ( $b != 0) {
    $remainder = $a % $b;
    $a = $b;
    $b = $remainder;
  }
  return abs($a);
}

/**
 * Converts an ingredient's quantity from fraction to decimal.
 */
function ingredient_quantity_from_fraction($ingredient_quantity) {
  // Replace a dash separated fraction with a ' ' to normalize the input string.
  $ingredient_quantity = preg_replace('/^(\d+)[\-](\d+)[\/](\d+)/', '${1} ${2}/${3}', $ingredient_quantity);

  if ($pos_slash = strpos($ingredient_quantity, '/')) {
    $pos_space = strpos($ingredient_quantity, ' ');

    // Can't trust $pos_space to be a zero value if there is no space
    // so set it explicitly.
    if ($pos_space === FALSE) {
      $pos_space = 0;
    }

    $whole = substr($ingredient_quantity, 0, $pos_space);
    $numerator = substr($ingredient_quantity, $pos_space, $pos_slash);
    $denominator = substr($ingredient_quantity, $pos_slash + 1);
    $ingredient_quantity = $whole+($numerator/$denominator);
  }

  return $ingredient_quantity;
}

/**
 * Returns a best-guess matched unit key for a unit of measure.
 *
 * @param string $subject
 *   The unit of measure for which the function will search.
 *
 * @return
 *   The unit's key from configuration or FALSE if there was no match.
 */
function ingredient_unit_fuzzymatch($subject) {
  $unit_sets = \Drupal::config('ingredient.units')->get('unit_sets');
  // Merge the unit sets into a single array for simplicity.
  $units = [];
  foreach ($unit_sets as $set) {
    $units = array_merge($units, $set['units']);
  }

  // Empty strings should use the default non-printing 'unit'.
  if (empty($subject)) {
    $subject = 'unit';
  }

  // First pass unit case must match exactly( T=Tbsp, t=tsp ).
  foreach ($units as $unit_key => $unit) {
    $patterns = array();
    // Add name pattern.
    $patterns[] = '^' . $unit['name'] . 's{0,1}$';
    // Add plural name pattern.
    $patterns[] = '^' . $unit['plural'] . 's{0,1}$';
    // Add abbreviation pattern.
    $patterns[] = '^' . $unit['abbreviation'] . 's{0,1}\.{0,1}$';
    // Add alias patterns.
    foreach ($unit['aliases'] as $alias) {
      $patterns[] = '^' . trim($alias) . 's{0,1}\.{0,1}$';
    }
    if (preg_match("/" . implode('|', $patterns) . "/", $subject)) {
      return $unit_key;
    }
  }

  // Second pass unit case doesn't matter.
  foreach ($units as $unit_key => $unit) {
    $patterns = array();
    // Add name pattern.
    $patterns[] = '^' . $unit['name'] . 's{0,1}$';
    // Add plural name pattern.
    $patterns[] = '^' . $unit['plural'] . 's{0,1}$';
    // Add abbreviation pattern.
    $patterns[] = '^' . $unit['abbreviation'] . 's{0,1}\.{0,1}$';
    // Add alias patterns.
    foreach ($unit['aliases'] as $alias) {
      $patterns[] = '^' . trim($alias) . 's{0,1}\.{0,1}$';
    }
    if (preg_match("/" . implode('|', $patterns) . "/i", $subject)) {
      return $unit_key;
    }
  }

  return FALSE;
}
